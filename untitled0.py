# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17Q7BvRQof5f99fh-lgsg0JhvWmR-iBSa

### **Hello World in TensorFlow**

**TensorFlow** is an open source library which allows to interact with machine learning projects.

Below is the program as a Hello World to TensorFlow in which we will provide Data(x,y as a numpy array) and the machine will understand the relation between data and results i.e., relation between x and y, then depending upon the answers it will predict the answers for other values.

First of all, we will **import the required libraries.**
"""

import tensorflow as tf
from tensorflow import keras
import numpy as np

"""**Keras** is an open source library written in Python. It is designed to enable fast experimentation with deep learning networks. *italicized text*

**Numpy** is an open source library used for working with arrays. *italicized text*
"""

model = keras.Sequential([keras.layers.Dense(units=1, input_shape = [1])])

"""**Sequential** is a one and the straightforward way to create Keras. It is limited to only single input and single output stacks of layers.

**Dense Layer** is the regular deeply connected neural network layer. It is the most commonly and frequently used layer of keras. *italicized text* 

**input_shape** is the dimensional shape of input. Like in this case, it is one dimensional.

**units** affects the number of units in the output layer.
"""

model.compile(optimizer = 'sgd', loss = 'mean_squared_error')

"""Optimizer and loss are the two fields of the compile. **Loss** determines the difference of accurate results from guess results. Based on the loss, **optimizer** makes another guess that maybe closer then the guess before."""

x = np.array([1,2,3,4,5,6,7,8], dtype = float)
y = np.array([3,5,7,9,11,13,15,17], dtype = float)

"""Two arrays are initialized.
The *x array is our data* and *y array is our answer*.

Depending on x and y our machine will learn the relation between x and y.

X and Y are fitted in model. **Epochs** is the number of guesses we required from the compiler. In this case, 1000 guesses are being made. More the number of epochs, more accurate the results will be.
"""

model.fit(x, y, epochs = 1000)

print(model.predict([10]))